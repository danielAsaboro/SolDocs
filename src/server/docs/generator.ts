import { AnchorIdl, AnchorInstruction, Documentation, getIdlName } from '../types';
import { AIClient } from '../ai/client';
import { overviewPrompt, instructionsPrompt, accountsPrompt, securityPrompt } from '../ai/prompts';

const INSTRUCTION_BATCH_SIZE = 5;

export class DocGenerator {
  private ai: AIClient;

  constructor(ai: AIClient) {
    this.ai = ai;
  }

  async generate(idl: AnchorIdl, programId: string, idlHash: string): Promise<Documentation> {
    console.log(`[DocGen] Starting documentation generation for "${getIdlName(idl)}" (${programId})`);

    // Pass 1: Program overview
    console.log(`[DocGen] Pass 1/4: Generating program overview...`);
    const overview = await this.ai.generate(overviewPrompt(idl, programId), 4096);

    // Pass 2: Instructions in batches
    console.log(`[DocGen] Pass 2/4: Generating instruction docs (${idl.instructions.length} instructions)...`);
    const instructionDocs = await this.generateInstructionDocs(idl.instructions, getIdlName(idl));

    // Pass 3: Account types
    console.log(`[DocGen] Pass 3/4: Generating account/type docs...`);
    const accountDocs = await this.generateAccountDocs(idl);

    // Pass 4: Security analysis
    console.log(`[DocGen] Pass 4/4: Generating security analysis...`);
    const security = await this.ai.generate(securityPrompt(idl, programId), 4096);

    // Combine into full documentation
    const fullMarkdown = this.assembleDoc(idl, programId, overview, instructionDocs, accountDocs, security);

    // Validate
    this.validateDoc(fullMarkdown);

    const doc: Documentation = {
      programId,
      name: getIdlName(idl),
      overview,
      instructions: instructionDocs,
      accounts: accountDocs,
      security,
      fullMarkdown,
      generatedAt: new Date().toISOString(),
      idlHash,
    };

    console.log(`[DocGen] Documentation complete for "${getIdlName(idl)}" (${fullMarkdown.length} chars)`);
    return doc;
  }

  private async generateInstructionDocs(instructions: AnchorInstruction[], programName: string): Promise<string> {
    const batches: AnchorInstruction[][] = [];
    for (let i = 0; i < instructions.length; i += INSTRUCTION_BATCH_SIZE) {
      batches.push(instructions.slice(i, i + INSTRUCTION_BATCH_SIZE));
    }

    const results: string[] = [];
    for (const batch of batches) {
      const batchNames = batch.map(i => i.name).join(', ');
      console.log(`[DocGen]   Batch: ${batchNames}`);
      const result = await this.ai.generate(instructionsPrompt(batch, programName), 6000);
      results.push(result);
    }

    return results.join('\n\n---\n\n');
  }

  private async generateAccountDocs(idl: AnchorIdl): Promise<string> {
    if (!idl.accounts?.length && !idl.types?.length && !idl.events?.length && !idl.errors?.length) {
      return '*No account types, custom types, events, or error codes defined in IDL.*';
    }
    return this.ai.generate(accountsPrompt(idl), 4096);
  }

  private assembleDoc(
    idl: AnchorIdl,
    programId: string,
    overview: string,
    instructions: string,
    accounts: string,
    security: string
  ): string {
    return `# ${getIdlName(idl)}

> **Program ID:** \`${programId}\`
> **Generated by SolDocs** â€” Autonomous Solana Program Documentation Agent
> **Generated at:** ${new Date().toISOString()}

---

${overview}

---

# Instructions

${instructions}

---

# Accounts & Types

${accounts}

---

# Security Analysis

${security}

---

*Documentation generated autonomously by SolDocs using AI analysis of the program's Anchor IDL.*
`;
  }

  private validateDoc(markdown: string): void {
    if (markdown.length < 500) {
      console.warn(`[DocGen] Warning: Generated docs are unusually short (${markdown.length} chars)`);
    }
    const hasCodeBlocks = markdown.includes('```');
    if (!hasCodeBlocks) {
      console.warn('[DocGen] Warning: No code blocks found in generated docs');
    }
  }
}
